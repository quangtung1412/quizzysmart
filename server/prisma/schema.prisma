datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id          String    @id @default(cuid())
  username    String?   @unique
  password    String?
  email       String?   @unique
  name        String?
  branchCode  String?
  picture     String?
  createdAt   DateTime  @default(now())
  role        String    @default("user") // 'admin' or 'user'
  aiSearchQuota Int     @default(10) // Number of AI search queries remaining (includes chat)
  quickSearchQuota Int  @default(50) // Number of quick search queries remaining (free trial)
  currentDeviceId String? // Currently logged in device ID
  currentSessionToken String? // Current session token for device validation
  pendingThankYouPopup Int @default(0) // Number of thank you popups pending to show (set to 1 after payment)
  bases       KnowledgeBase[]
  attempts    Attempt[]
  assignments TestAssignment[]
  subscriptions Subscription[]
  aiSearchHistory AiSearchHistory[]
  chatMessages ChatMessage[]  // RAG chat history
  geminiApiCalls GeminiApiCall[] // API calls tracking
}

model KnowledgeBase {
  id        String     @id @default(cuid())
  name      String
  createdAt DateTime   @default(now())
  user      User       @relation(fields: [userId], references: [id])
  userId    String
  questions Question[]
  attempts  Attempt[]
}

model Question {
  id                String   @id @default(cuid())
  text              String
  options           String   // JSON array string
  correctAnswerIdx  Int
  source            String?
  category          String?
  base              KnowledgeBase @relation(fields: [baseId], references: [id])
  baseId            String
  answers           AttemptAnswer[]
}

model Attempt {
  id             String          @id @default(cuid())
  mode           String
  startedAt      DateTime        @default(now())
  completedAt    DateTime?
  score          Float?
  settings       String          // JSON string
  user           User            @relation(fields: [userId], references: [id])
  userId         String
  knowledgeBase  KnowledgeBase?  @relation(fields: [knowledgeBaseId], references: [id])
  knowledgeBaseId String?
  test            Test?           @relation(fields: [testId], references: [id])
  testId          String?
  answers        AttemptAnswer[]
}

model AttemptAnswer {
  id              String   @id @default(cuid())
  selectedIndex   Int?
  isCorrect       Boolean?
  attempt         Attempt  @relation(fields: [attemptId], references: [id])
  attemptId       String
  question        Question @relation(fields: [questionId], references: [id])
  questionId      String
}

model Test {
  id                String           @id @default(cuid())
  name              String
  description       String?
  questionCount     Int              // Total number of questions in the test
  timeLimit         Int              // Time limit in minutes
  maxAttempts       Int              @default(0) // Maximum number of attempts allowed (0 = unlimited)
  startTime         DateTime?        // When users can start taking the test
  endTime           DateTime?        // When the test expires
  knowledgeSources  String           // JSON string: array of {knowledgeBaseId, percentage}
  questionOrder     String           // JSON string array of question IDs (generated randomly)
  isActive          Boolean          @default(true)
  createdAt         DateTime         @default(now())
  attempts          Attempt[]
  assignments       TestAssignment[]
  
  // Remove the single knowledge base relation since we now support multiple
  @@map("tests")
}

model TestAssignment {
  id         String   @id @default(cuid())
  test       Test     @relation(fields: [testId], references: [id])
  testId     String
  user       User     @relation(fields: [userId], references: [id])
  userId     String
  assignedAt DateTime @default(now())
  @@unique([testId, userId])
}

model StudyPlan {
  id              String            @id @default(cuid())
  userId          String
  knowledgeBaseId String
  knowledgeBaseName String
  title           String?           // Optional display name for multiple plans
  totalDays       Int
  minutesPerDay   Int
  questionsPerDay Int
  currentPhase    String            @default("initial") // 'initial' or 'review'
  startDate       DateTime
  endDate         DateTime
  currentDay      Int               @default(1)
  newQuestionsLearned Int           @default(0)
  completedQuestions String          @default("[]") // JSON array of question IDs marked as "easy"
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  questionProgress QuestionProgress[]
}

model QuestionProgress {
  id              String     @id @default(cuid())
  studyPlan       StudyPlan  @relation(fields: [studyPlanId], references: [id], onDelete: Cascade)
  studyPlanId     String
  questionId      String
  difficultyLevel String?    // null = not rated yet, 'easy', 'medium', 'hard'
  lastReviewed    DateTime?
  reviewCount     Int        @default(0)
  nextReviewAfter Int?       // Number of new questions to learn before reviewing this again
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt
  
  @@unique([studyPlanId, questionId])
}

model SubscriptionPlan {
  id          String   @id @default(cuid())
  planId      String   @unique // 'plus' or 'premium'
  name        String   // Display name
  price       Int      // Price in VND
  aiQuota     Int      // AI search quota included
  duration    Int      // Duration in days
  features    String   // JSON array of feature strings
  isActive    Boolean  @default(true)
  displayOrder Int     @default(0) // Order to display plans
  popular     Boolean  @default(false) // Is this the popular/recommended plan?
  bestChoice  Boolean  @default(false) // Is this the best choice/recommended plan?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@map("subscription_plans")
}

model Subscription {
  id              String   @id @default(cuid())
  user            User     @relation(fields: [userId], references: [id])
  userId          String
  plan            String   // 'plus' or 'premium'
  price           Int      // Price in VND
  aiQuota         Int      // AI search quota included
  duration        Int      // Duration in days
  status          String   @default("pending") // 'pending', 'active', 'expired', 'cancelled'
  paymentMethod   String   @default("bank_transfer") // 'bank_transfer'
  transactionCode String   @unique // User ID + Plan code for transfer content
  telegramMessageId String? // ID of Telegram message for this subscription
  // PayOS payment link info
  qrCode          String?  // Base64 QR code image
  checkoutUrl     String?  // PayOS checkout URL
  accountNumber   String?  // Bank account number
  accountName     String?  // Bank account name
  bin             String?  // Bank BIN
  paymentLinkId   String?  // PayOS payment link ID
  description     String?  // Payment description (short code)
  purchasedAt     DateTime @default(now())
  activatedAt     DateTime?
  expiresAt       DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model AiSearchHistory {
  id                String   @id @default(cuid())
  user              User     @relation(fields: [userId], references: [id])
  userId            String
  // Input data
  imageBase64       String?  // Optionally store the image (can be large)
  knowledgeBaseIds  String   // JSON array of knowledge base IDs searched
  // AI Response
  recognizedText    String   // Question text extracted by AI
  extractedOptions  String?  // JSON object of extracted A/B/C/D options
  matchedQuestionId String?  // ID of matched question (if found)
  matchedQuestion   String?  // Full matched question data (JSON)
  confidence        Int      // Confidence score (0-100)
  // Model & Token info
  modelUsed         String   // e.g., "gemini-2.5-flash"
  modelPriority     Int      // Priority of model used
  inputTokens       Int      // Number of input tokens
  outputTokens      Int      // Number of output tokens
  totalTokens       Int      // Total tokens used
  // Metadata
  responseTime      Int      // Response time in milliseconds
  success           Boolean  @default(true) // Whether search was successful
  errorMessage      String?  // Error message if failed
  createdAt         DateTime @default(now())
  
  @@index([userId])
  @@index([createdAt])
  @@index([modelUsed])
}

model SystemSettings {
  id                    String   @id @default(cuid())
  // Model Rotation Settings
  modelRotationEnabled  Boolean  @default(true) // Whether to use model rotation or stick to default model
  defaultModel          String   @default("gemini-2.5-flash") // Default model to use when rotation is disabled
  // Peak Hours Settings
  peakHoursEnabled      Boolean  @default(false) // Whether peak hours restrictions are active
  peakHoursStart        String?  // Start time in HH:MM format (24-hour)
  peakHoursEnd          String?  // End time in HH:MM format (24-hour)
  peakHoursDays         String   @default("[]") // JSON array of days (0=Sunday, 6=Saturday)
  // Metadata
  updatedAt             DateTime @updatedAt
  updatedBy             String?  // Admin user ID who last updated
  
  @@map("system_settings")
}

model ModelSettings {
  id                String   @id @default(cuid())
  defaultModel      String   @default("gemini-2.5-flash") // Default model for regular queries
  cheaperModel      String   @default("gemini-2.0-flash-lite") // Cheaper/lighter model for simple queries
  embeddingModel    String   @default("gemini-embedding-001") // Model for embeddings in RAG
  // Metadata
  updatedAt         DateTime @updatedAt
  updatedBy         String?  // Admin user email who last updated
  
  @@map("model_settings")
}

// ============================================
// RAG (Retrieval-Augmented Generation) Models
// ============================================

model Document {
  id                String   @id @default(cuid())
  fileName          String   // Original PDF filename
  fileSize          Int      // File size in bytes
  filePath          String   // Local file path
  uploadedAt        DateTime @default(now())
  uploadedBy        String   // Admin user ID
  
  // Document metadata (extracted by Gemini)
  documentNumber    String?  // Số văn bản
  documentName      String   // Tên văn bản
  documentType      String?  // Loại văn bản (Thông tư, Nghị định, etc.)
  issuingAgency     String?  // Cơ quan ban hành
  signerName        String?  // Người ký
  signerTitle       String?  // Chức danh người ký
  signedDate        DateTime? // Ngày ký
  
  // Content storage
  rawContent        String   // Full JSON extracted content
  markdownContent   String   // Markdown formatted full content
  
  // Vector database references
  qdrantCollectionName String @default("vietnamese_documents")
  qdrantPointIds    String   @default("[]") // JSON array of point IDs in Qdrant
  
  // Processing status
  processingStatus  String   @default("processing") // processing, completed, failed
  errorMessage      String?
  processingStartedAt DateTime @default(now())
  processingCompletedAt DateTime?
  
  // Relations
  chunks            DocumentChunk[]
  chatMessages      ChatMessage[]
  
  @@index([uploadedBy])
  @@index([processingStatus])
  @@index([uploadedAt])
  @@map("documents")
}

model DocumentChunk {
  id              String   @id @default(cuid())
  documentId      String
  chunkIndex      Int      // Sequential index
  chunkType       String   // 'overview', 'basis', 'chapter', 'article', 'section'
  
  // Content
  content         String   // Markdown text content of this chunk
  
  // Hierarchy metadata (JSON string)
  metadata        String   // {documentNumber, documentName, chapter?, article?, section?, etc}
  
  // Vector reference
  qdrantPointId   String?  // Point ID in Qdrant vector DB
  embeddingStatus String   @default("pending") // pending, completed, failed
  
  createdAt       DateTime @default(now())
  
  // Relations
  document        Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  
  @@index([documentId])
  @@index([chunkType])
  @@index([embeddingStatus])
  @@map("document_chunks")
}

model ChatMessage {
  id              String   @id @default(cuid())
  userId          String
  documentId      String?  // Optional: specific document context
  
  // Conversation
  userMessage     String   // User's question
  botResponse     String   // AI generated answer
  
  // RAG metadata (JSON strings)
  retrievedChunks String?  // JSON array of {chunkId, score, content}
  modelUsed       String?  // Which Gemini model was used
  
  // Token usage
  inputTokens     Int      @default(0)
  outputTokens    Int      @default(0)
  totalTokens     Int      @default(0)
  
  // Search metadata
  isDeepSearch    Boolean  @default(false) // Whether this was a deep search request
  confidence      Float?   // AI confidence score (0-100)
  cacheHit        Boolean  @default(false) // Whether answer came from cache
  
  createdAt       DateTime @default(now())
  
  // Relations
  user            User     @relation(fields: [userId], references: [id])
  document        Document? @relation(fields: [documentId], references: [id])
  
  @@index([userId])
  @@index([documentId])
  @@index([createdAt])
  @@index([isDeepSearch])
  @@map("chat_messages")
}

// ============================================
// Gemini API Tracking & Monitoring
// ============================================

model GeminiApiCall {
  id                String   @id @default(cuid())
  
  // Request info
  endpoint          String   // 'generateContent', 'embedContent', 'generateContentStream', 'extractDocument'
  modelName         String   // Model used (gemini-2.5-flash, etc.)
  modelPriority     Int      @default(0) // Priority from model rotation
  
  // User context
  userId            String?  // User who made the request (if applicable)
  user              User?    @relation(fields: [userId], references: [id])
  requestType       String   // 'chat', 'search', 'embedding', 'document_extraction', 'query_preprocessing'
  sessionId         String?  // Groups multiple API calls from single user request
  
  // Token usage
  inputTokens       Int      @default(0)
  outputTokens      Int      @default(0)
  totalTokens       Int      @default(0)
  
  // Cost calculation (in USD)
  inputCost         Float    @default(0.0)  // Cost for input tokens
  outputCost        Float    @default(0.0)  // Cost for output tokens
  totalCost         Float    @default(0.0)  // Total cost
  
  // Performance metrics
  startTime         DateTime @default(now())
  endTime           DateTime?
  duration          Int      @default(0) // Duration in milliseconds
  
  // Status
  status            String   @default("pending") // 'pending', 'success', 'error', 'retried'
  errorMessage      String?
  retryCount        Int      @default(0)
  
  // Additional metadata (JSON string)
  metadata          String?  // {question, chunkCount, cacheHit, confidence, etc.}
  
  // Indexes for querying
  @@index([userId])
  @@index([modelName])
  @@index([requestType])
  @@index([startTime])
  @@index([status])
  @@index([sessionId])
  @@map("gemini_api_calls")
}